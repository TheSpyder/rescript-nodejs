// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var Zora = require("zora");
var Curry = require("rescript/lib/js/curry.js");
var Stream = require("stream");
var StreamTestLib$NodeJs = require("../module/StreamTestLib.bs.js");

function $$then(prim0, prim1) {
  return prim0.then(Curry.__1(prim1));
}

function done(prim) {
  return Promise.resolve(prim);
}

Zora.test("Stream.Readable", (function (t) {
        t.test("'Stream.Readable.make' should return a defined value", (function (t) {
                var readable = StreamTestLib$NodeJs.makeReadableEmpty(undefined);
                t.notEqual(readable, undefined, "");
                
              }));
        t.test("'Stream.Readable.make' should return an instance of 'Readable'", (function (t) {
                var readable = StreamTestLib$NodeJs.makeReadableEmpty(undefined);
                t.equal(readable.constructor.name, "Readable", "");
                
              }));
        t.test("'Stream.Readable.pipe' returns a writable stream", (function (t) {
                var readable = StreamTestLib$NodeJs.makeReadableEmpty(undefined);
                var writable = StreamTestLib$NodeJs.makeWritableEmpty(undefined);
                t.equal(readable.pipe(writable), writable, "");
                
              }));
        t.test("'Stream.Readable.destroyWithError' should emit 'error' event", (function (t) {
                var dummyError = new Error("Expected error: Stream destroyed");
                return new Promise((function (resolve, _reject) {
                              var stream = StreamTestLib$NodeJs.makeReadableEmpty(undefined).on("error", (function (err) {
                                      t.equal(err, dummyError, "");
                                      return resolve(undefined);
                                    }));
                              setTimeout((function (param) {
                                      stream.destroy(dummyError);
                                      
                                    }), 10);
                              
                            }));
              }));
        t.test("'Stream.Readable.destroy' should return the exact same instance of 'Readable'", (function (t) {
                var readable = StreamTestLib$NodeJs.makeReadableEmpty(undefined);
                t.equal(readable.destroy(), readable, "");
                
              }));
        
      }));

Zora.test("Stream.Writable", (function (t) {
        t.test("'Stream.Writable.make' should return a defined value", (function (t) {
                var writable = StreamTestLib$NodeJs.makeWritableEmpty(undefined);
                t.notEqual(writable, undefined, "");
                
              }));
        t.test("'Stream.Writable.make' should return an instance of 'Writable'", (function (t) {
                var writable = StreamTestLib$NodeJs.makeWritableEmpty(undefined);
                t.equal(writable.constructor.name, "Writable", "");
                
              }));
        t.test("Stream.Writable.makeObjMode should have a 'write' function with the correct function signature", (function (t) {
                var args = {
                  contents: undefined
                };
                var options = {
                  objectMode: true,
                  write: (function (data, encoding, callback) {
                      var wstream = this ;
                      args.contents = [
                        wstream,
                        data,
                        encoding,
                        callback
                      ];
                      return Curry._1(callback, undefined);
                    })
                };
                return new Promise((function (resolve, _reject) {
                              var writeStream = new Stream.Writable(options);
                              writeStream.write(42, (function (param) {
                                      var match = args.contents;
                                      var actual = match !== undefined ? [
                                          match[0].constructor.name === "Writable",
                                          typeof match[1] === "number",
                                          typeof match[2] === "string",
                                          typeof match[3] === "function"
                                        ] : undefined;
                                      t.equal(actual, [
                                            true,
                                            true,
                                            true,
                                            true
                                          ], "");
                                      return resolve(undefined);
                                    }));
                              
                            }));
              }));
        
      }));

exports.$$then = $$then;
exports.done = done;
/*  Not a pure module */
